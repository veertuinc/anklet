package main

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

// PluginInfo holds information about discovered plugins
type PluginInfo struct {
	Name       string
	Type       string
	ImportPath string
}

const pluginTemplate = `// Code generated by generate-plugins. DO NOT EDIT.
// Code generated by generate-plugins. DO NOT EDIT.
// Code generated by generate-plugins. DO NOT EDIT.

package plugins

import (
	"context"
	"fmt"

	"github.com/veertuinc/anklet/internal/config"
	"github.com/veertuinc/anklet/internal/plugins/plugin"
	
	// Auto-generated plugin imports
{{- range .}}
	_ "github.com/veertuinc/anklet/plugins/{{.Type}}s/{{.Name}}"
{{- end}}
)

func Run(
	workerCtx context.Context,
	pluginCtx context.Context,
	pluginCancel context.CancelFunc,
) (context.Context, error) {
	ctxPlugin, err := config.GetPluginFromContext(pluginCtx)
	if err != nil {
		return pluginCtx, err
	}
	if ctxPlugin.Plugin == "" {
		return pluginCtx, fmt.Errorf("plugin is not set in yaml:plugins:%s:plugin", ctxPlugin.Name)
	}
	
	// Get plugin from global registry
	pluginImpl, exists := plugin.Get(ctxPlugin.Plugin)
	if !exists {
		return pluginCtx, fmt.Errorf("plugin '%s' not found in registry", ctxPlugin.Plugin)
	}
	
	// Handle context cancellation for handlers (receivers handle this internally)
	if pluginImpl.Type() == "handler" {
		select {
		case <-pluginCtx.Done():
			pluginCancel()
			return pluginCtx, nil
		default:
			// Continue with plugin execution
		}
	}
	
	// Execute the plugin
	updatedPluginCtx, err := pluginImpl.Run(workerCtx, pluginCtx, pluginCancel)
	if err != nil {
		return updatedPluginCtx, fmt.Errorf("error running %s plugin: %s", ctxPlugin.Plugin, err.Error())
	}
	
	return updatedPluginCtx, nil
}
`

func main() {
	if len(os.Args) < 3 {
		fmt.Println("Usage: generate-plugins <plugins-dir> <output-file>")
		os.Exit(1)
	}

	pluginsDir := os.Args[1]
	outputFile := os.Args[2]

	plugins, err := discoverPlugins(pluginsDir)
	if err != nil {
		fmt.Printf("Error discovering plugins: %v\n", err)
		os.Exit(1)
	}

	if err := generatePluginsFile(plugins, outputFile); err != nil {
		fmt.Printf("Error generating plugins file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s with %d plugins\n", outputFile, len(plugins))
}

// discoverPlugins scans the plugins directory for plugin subdirectories
func discoverPlugins(pluginsDir string) ([]PluginInfo, error) {
	var plugins []PluginInfo

	// Scan handlers
	handlersDir := filepath.Join(pluginsDir, "handlers")
	handlerPlugins, err := scanPluginType(handlersDir, "handler")
	if err != nil {
		return nil, fmt.Errorf("error scanning handlers: %w", err)
	}
	plugins = append(plugins, handlerPlugins...)

	// Scan receivers
	receiversDir := filepath.Join(pluginsDir, "receivers")
	receiverPlugins, err := scanPluginType(receiversDir, "receiver")
	if err != nil {
		return nil, fmt.Errorf("error scanning receivers: %w", err)
	}
	plugins = append(plugins, receiverPlugins...)

	return plugins, nil
}

// scanPluginType scans a specific plugin type directory
func scanPluginType(typeDir, pluginType string) ([]PluginInfo, error) {
	var plugins []PluginInfo

	if _, err := os.Stat(typeDir); os.IsNotExist(err) {
		// Directory doesn't exist, return empty list
		return plugins, nil
	}

	entries, err := os.ReadDir(typeDir)
	if err != nil {
		return nil, fmt.Errorf("error reading directory %s: %w", typeDir, err)
	}

	for _, entry := range entries {
		if entry.IsDir() {
			pluginDir := filepath.Join(typeDir, entry.Name())

			// Check if plugin.go exists
			pluginFile := filepath.Join(pluginDir, "plugin.go")
			if _, err := os.Stat(pluginFile); err == nil {
				plugins = append(plugins, PluginInfo{
					Name:       entry.Name(),
					Type:       pluginType,
					ImportPath: fmt.Sprintf("github.com/veertuinc/anklet/plugins/%ss/%s", pluginType, entry.Name()),
				})
			}
		}
	}

	return plugins, nil
}

// generatePluginsFile generates the plugins.go file with auto-discovered imports
func generatePluginsFile(plugins []PluginInfo, outputFile string) error {
	tmpl, err := template.New("plugins").Parse(pluginTemplate)
	if err != nil {
		return fmt.Errorf("error parsing template: %w", err)
	}

	file, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("error creating output file: %w", err)
	}
	defer func() {
		if closeErr := file.Close(); closeErr != nil {
			fmt.Printf("Warning: error closing file: %v\n", closeErr)
		}
	}()

	if err := tmpl.Execute(file, plugins); err != nil {
		return fmt.Errorf("error executing template: %w", err)
	}

	return nil
}
